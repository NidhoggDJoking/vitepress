import{_ as l,o as c,c as a,e as d,w as r,a as n,b as e,r as s,d as t}from"./app.b11d4031.js";const T=JSON.parse('{"title":"Svelte","description":"","frontmatter":{"outline":"deep","aside":false},"headers":[],"relativePath":"note/svelte.md","lastUpdated":1681539010000}'),_={name:"note/svelte.md"},i=n('<h1 id="svelte" tabindex="-1">Svelte <a class="header-anchor" href="#svelte" aria-hidden="true">#</a></h1><p>2020年<br> 前端三大框架：<code>Angular</code>，<code>Vue</code>，<code>React</code> 这是别人的标准<br> 我的心中标准是 <code>Vue</code>，<code>React</code>，<code>Svelte</code></p><p>我与2019年开始接触 <code>Angular</code> 的项目，当时的第一印象是 <b>笨重</b><br> 运行超慢，代码臃肿 虽然它的真正严格意义上的框架，但是我并不喜欢，随后我们团队将公司的 <code>Angular</code> 项目用 <code>Vue</code> 重写完. <br></p><p>同年在 <a href="https://2019.stateofjs.com/" target="_blank" rel="noreferrer">stateofjs</a> 注意到了进入前端框架T1队列的 <code>Svelte</code> (19年把 <code>Polymer</code> 挤下去成功上位)<br></p><p>期初 <code>Svelte</code> 热度并不高但身为前端开发我还是本能的尝试使用了下，发现它的框架定义居然是<code>编译器</code>(如下文档原文)<br> 随后的几年 <code>Svelte</code> 如雨后春笋势如破竹，在框架热度，运行速度，打包大小，受欢迎度名列前茅<br> 于是20年开始我在开发论坛中疯狂安利希望加快一点国内的推广，促使生态发展，早点干掉 <code>Angular</code></p><hr>',6),p=e("p",null,[e("code",null,"Svelte"),t(" 是一种全新的构建用户界面的方法。传统框架如 "),e("code",null,"React"),t(" 和 "),e("code",null,"Vue"),t(" 在浏览器中需要做大量的工作，而 "),e("code",null,"Svelte"),t(" 将这些工作放到构建应用程序的编译阶段来处理。")],-1),u=e("p",null,[t("与使用虚拟（virtual）DOM 差异对比不同。"),e("code",null,"Svelte"),t(" 编写的代码在应用程序的状态更改时就能像做外科手术一样更新 DOM。")],-1),h=e("ul",null,[e("li",null,[e("p",null,[e("a",{href:"https://gitee.com/NidhoggDJoking/svelte",target:"_blank",rel:"noreferrer"},"Svelte 初体验")])]),e("li",null,[e("p",null,[e("a",{href:"https://github.com/NidhoggDJoking/JSvelte",target:"_blank",rel:"noreferrer"},"Svelte + Vite 生态研究案例")])])],-1);function v(f,S,g,b,m,V){const o=s("collapse");return c(),a("div",null,[i,d(o,{title:"文档原文"},{default:r(()=>[p,u]),_:1}),h])}const k=l(_,[["render",v]]);export{T as __pageData,k as default};
